# Core Protocol Working Group Meeting 07, October 31, 2024 - Transcript

**Attendees**

Alex Hentschel,
Bastian Mueller,
Dieter Shirley,
Leo Zhang,
Jan Bernatik,
Janez Podhostnik,
Jerome Pimmel,
Jordan Schalm,
Peter Argue,
Vishal Changrani



## Transcript


**Dieter Shirley**:
Hey there, everyone. So we want to talk about versioning. I asked to have a pregame with Alex and Bastian because I feel So versioning is a topic that it's very easy to get out of hand. And there are a bunch of ways that ultimately we will need to provide versioning. And I wanted to keep this discussion as narrow as possible. But also, I wanted to create a little bit of context. Because even just when we were talking, Alex, Bastian, and I together, where we thought we all knew what we were talking about, it actually took a little while for us to get a shared language. And so I thought it'd be useful to sort of share this now. So what's the right way to think about this? The first thing is that presumably, at least this is what I do, and I'm going to guess that many of you are the same way. When you think about versioning, you think about the version of the software that's running, right? So the easiest way to think about it is that that's just the commit hash. In GitHub that represents that representation of the code, and that's what's running, right? We're mostly not talking about that today. Obviously, what we're talking about has implications for that, but we're not going to talk about that today. The other thing that we can think of that, the other obvious example of versioning is like cadence, right? Cadence went to 1.0 recently. And that's mostly, again, that's a tiny little subset of what we're doing, but we're not going to talk explicitly about that. What we want to talk about, and this is so subtle, and I don't know if I have the right words, so I apologize if what I say seems very obvious to everyone, because I'm going to be a little pedantic. What we're talking about is the versioning required to coordinate different nodes talking to each other, which might be using different software versions, and I want to very carefully use that term, software versions, to refer to that git commit hash, that multiple software versions might be able to talk to each other if they agree on the versioning of the messaging they're using. And Alex has proposed, and I also proposed that we adopt this, that we use the term component versioning for that. And so software versions can speak component versions, but as we go forward, it is likely the case that different software. We'll have a bunch of different software versions. Most of them will talk the same component versions, but many of them will also talk multiple component versions. So I'll give a very concrete example here, which is easy to talk about and sounds trivial, but it's not a code change anyone would ever want to make. But what if we decided we wanted to change our hashing function? We decide, hey, SHA-3, that's old and grody. We want to switch to to Blake hashing. It's going to be so much faster, and the protocol is going to be so much better. Everything else about the protocol is the same, except how we compute these hashes, but also how we check these hashes. We need some way to know, is the node that I'm talking to on the other side going to understand that I'm using one hashing algorithm versus the other hashing algorithm? How can we do that? We have a component version, and that component version is In that case, it might be the protocol will have different components like execution, protocol, maybe networking, things like that. And it'll say, how is that guy? How do we know that the two of us are going to agree on which component version to use? We need a system for agreeing on that. And Alex has built such a system. Now, you might think that such a system is relatively easy to build. We built a version beacon previously to try and solve this problem. It turns out that it's not an easy problem to solve. I don't want to go too much detail, but fundamentally, in a blockchain, you can't know what the other person thinks the state of the world is. And so we need a coordination mechanism that is based on building blocks. And building blocks has a lot of complexities. For example, building blocks can fork. There can be two blocks. Sort of at the same height, you know, they wouldn't be finalized yet, but they can be too, right? What if the component versions are different between those for some reason? How do you manage that? How do you, what do you do if there's a view and we've agreed we're going to change the version of a particular view, but there's no block in that view, right? Because there's a timeout. And so now it's going to have to be the next block. And so there's, and you can't do it based on blocks. You have to do it based on views because block can be subjective because of all of this forking and whatnot. Alex has built an MPP version of a system that should make it easy for you. You should just be able to say, hey, what's the current component version at that now? Whatever I am at, at this block height, at this view, whatever you want to think of it as, Right now, if I'm communicating to other nodes, what component versions should I use and what component versions should I expect and interpret the byte data as? And so now there's two really important aspects to the system. So that's the now question, right? So then we have two other tenses, future tense and past tense. So this system also allows us to do future and past tense. So what we mean by future is we can, ahead of time, say at such and such a view, which reliably maps to a point in time, quite reliably, not perfectly reliably, maps to a point in time. We can say at Tuesday at 8 o'clock, we should be at such and such a view height, so at such and such a view we're going to switch the component version of this. We can predict that ahead of time. It allows us to turn what would previously have been an HCU into a rolling update that triggers at a particular height in what I'm going to brand, at least internally, as instant updates. What we can do is we can say, so I'll go back to my hashing example. Let's say we do want to change the hash. A week ahead of time, two weeks ahead of time, we deploy code that has an if statement, right? There's a hash this data function, and it has an if statement in it. And it says, if we're at this component version, I'll use SHA-3. If we're at this component version, I'm going to use Blake, right? And that code, that can be sitting there. The node operator can update it the day before the height happens. They can update it a week before. It doesn't matter because it's going to keep using the old component version until we hit that time. And at exactly that time every everybody is going to be coordinated, and they're all going to start using the new version. And so it lets us make pretty aggressive changes that previously would have had to be a high-coordinated update, which involves rebooting all of the nodes, into something that can happen with literally zero downtime. And so the first big ask of anyone listening to me is that if you're considering doing any sort of change to the protocol that wouldn't be normally done with a rolling update. In other words, it involves some aspect of changing how nodes communicate with each other or changing the state that nodes communicate with each other. Then look into using this. Now, there will be examples where that just doesn't work, where the logic is just too complex. Actually, if we go back to my hash example, that's probably true. The number of places where we hash and all that stuff, putting an if and else around all of those is probably going to lead to very sad-looking diffs and potentially really problematic, a risky release. And so we may decide actually putting an if-else on this particular change is too complex. We still want to do an HCU. But man, I'll bet you there's a bunch of things that we've done HCUs for in the past that could be done with this, which would allow us to have zero downtime updates or instant updates. I'm going to keep using that word in the hope that it takes off. So that's the forward-looking one. The backwards-looking aspect is also really important, which is, well, I'm going to look at some data, a block that was built, an event specification that happened, maybe even like a QC or something like that from last week. I'm going to look at some piece of data, some piece of data that is shared between nodes that came from last week. How do I know that it's the same component version that I have now? Again, this system will allow us to say, okay, I'm going to look at this block of data. It comes from this era. What component versions should I expect here? And do I then have the ability to understand this? So where this gets really powerful is with something like cadence, right? So, or at least it's easy to imagine. It's easy to think about when you think about cadence. Maybe I think it's powerful everywhere, but I think in cadence it's easier to reason about. And cadence can say, hey, I'm gonna run from this block error. And we subtly changed some behavior. It was a weird edge case that But it turned out that some people depended on it, but other people could exploit it. And so no one actually deployed any code that exploited it in the past. But we're going to change how it works in the future. And the two smart contracts that depended on that side effect, they've been updated. And so in the future, it's not a problem to change this behavior, this weird edge case. But in the past, people actually depended on it. And so we want to have, in the cadence interpreter, If we're reading an old smart contract that was deployed that depended on this edge case that wasn't malicious, we're going to run the old code path. But if we're running new code, we want to do the new, more secure code path. But we don't want to break history. We don't want to answer differently than we would have if you had asked us a week ago. This system allows that. Now, hopefully, we'll never end up in that situation. But this system makes it possible.

**Jan Bernatik**:
Jan, did you want to jump in? I just wanted to mention, maybe I'm slightly misunderstanding something here. But we literally, on Tuesday, deployed RunHCU, which deploys a change where we can do exactly this, what you're describing here. It exposes version beacon from FEM to Cadence, and then Cadence can use that to basically have a feature toggle. And we use the HCU event to toggle that feature on and off. So yeah, we're planning to use this for future Cadence security fixes, for example.

**Dieter Shirley**:
So this is one of the reasons why we wanted to make sure we talked about this, Jan, is that we do have multiple mechanisms for this right now. And we really need to make sure we have one. And my understanding, and I haven't talked to Alex about this extensively, but my understanding is that the old version beacon is not especially robust and that we want to move to something that is more robust and which is updated as part of the protocol state. And so the point of this meeting is to say, look, here's this new mechanism. From the outside, it looks like it solves the same problem as the version beacon, but it's intended to be more robust, more extensible, more useful in the future. And so we want to make sure everyone understands it and can switch to it. But you're right, Jan, I'm basically describing the thing that version beacon was supposed to solve. And I just wanted to make sure that the people who hadn't interacted with that code understood what we were talking about. Go ahead, make sense.

**Unidentified Speaker**:
Yeah.

**Dieter Shirley**:
Now, I do want to say that If you are changing a component version, since the Crescendo release, I consider it part of the network promise that we can access data back to the Crescendo sport. Especially in EVM, it's very common to do historical queries. We know a lot of people in Cadence haven't done that. But now that we've locked down Cadence 1.0, people are going to start to expect that. Now, we haven't explicitly promised that, but people are going to start to expect it. And people are going to be very annoyed and disappointed if that is not true. And so I'm not saying that 100% like, you know, like, you know, kill yourselves writing a million little versions of code, backwards compatibility, we can, you know, if it's super extreme, we can talk about it, we can have a discussion about it. But I want everyone, I would like it to be the case as much as possible, that all of your software versions going forward have the ability to handle all of the component versions starting today. So by default, you shouldn't think of this component version thing as a temporary thing. Ideally, you should start to think of this as part of your workflow. How do we sustainably keep that old logic around that understands how those old blocks work without making a maintenance nightmare for ourselves, I don't know, is Rempton here? So if you, Rempton has looked in the EBM code base or the geth code base, and it is a mess, right? And so one of the problems we're gonna have to figure out how to solve is how do we keep this from becoming a mess? And how do we keep just like regular normal functions from having a bunch of if statements in them that are like, well, if we're at this component version, do it this way, and if we're at this component version, do it the other way. Can we do that in a more rational way?

**Unidentified Speaker**:
Peter. So yeah, just just clarifying.

**Peter Argue**:
So it sounds like you're envisioning that these. Like code forks are going to stay in the code base. Long term and not be, you know, a short term conditional that we use during the upgrade and then remove in a subsequent upgrade.

**Dieter Shirley**:
Yes, I mean it kind of depends, right? So there are some messages that we would anticipate having to parse again in the past, right? So there's a message that goes from consensus nodes to the leader that says, I vote for this block. Those votes are then combined together and put in the block header. And then no one ever looks at those votes again, right? Because all of the data from those individual votes are going in there. That's an example of something where if we change how that is formatted, it might be a code path that goes away in time. However, if the way that that data is encoded in the block header changes, then that is a way something that we would want to maintain long-term because you never know when someone's going to come along and say, I want to see the block header for this block in October of 2024 and know that the state root hash is accurate and then I can verify that this data is correct based on that state root hash. That is arguably part of the promise of being a blockchain and it's gotten to the point where I think we're ready to start living up to that promise. I want to be clear that what we're doing here is we're not closing the door. We're not sealing up the door. We're closing the door, putting a lock on it where the key is hanging right next to it that says, let's have a discussion before you use this key. We're not saying we can't ever do that. We're saying that's something that we should strenuously avoid and a warning that at some point in time in the not too distant future, we will probably throw away that key and maybe even seal up that door if that analogy makes sense.

**Peter Argue**:
So not to get into implementation details, but what it sounds like is it's more important. That the importance of this is related to data availability, not necessarily node operations, and so it's about data egress. So people being able to get access to this data and having a consistent view of that data.

**Dieter Shirley**:
Yeah, it's it's it. Part of it is data availability, but it's not just data availability. It's data availability with the added cryptographic protections that allow us to prove that that data was accurate. So yes, it's having access to that data. But we also want to get to the point where it's not just, oh, yeah, this is what the state of the world was back then. We can read this data. But we can do all of the same promises that we do today, which is, no, no, look, I can show you. There's a Merkle tree. There's a state root hash. There's a signed block. We can trace that all back. And we don't want to get to the point where we're, oh, Alex is rabbit holing.

**Unidentified Speaker**:
Yes, yes.

**Alex Hentschel**:
So we're in the weeds completely. We're not talking about the thing we need to be talking about, the execution stack versioning. You kind of went in 20 minutes, flew through most of the documents. I don't know if anyone has internalized any of that. And I'm a little bit lost now what to do.

**Dieter Shirley**:
Thank you for the time out, Alex. You're absolutely right. I'm giving you the heads up about the door and the key and all of that, but we're not going to talk about that today. That's not what we're here to talk about. I apologize. I maybe shouldn't have even brought that up. What the point of this meeting is, is for you to all understand that this new mechanism exists. Anytime you need any versioning stuff, you should use this new mechanism. Alex is going to talk a little bit more at the details of what is going to be in there. Before I hand it off to Alex, I'll let Vishal ask his last question here.

**Vishal Changrani**:
Yeah, my question is this is actually a pretty fundamental change on how we have done things because the rationale for us to do these HCUs and spokes was because we intentionally wanted to avoid these if statements. And now we're saying that we're at a point of maturity where we can no longer avoid it, so we probably have to do it. So just want to make sure that that's one of the rabbit holes I don't want to get into.

**Alex Hentschel**:
is not important for this discussion, because if you do not have any if statements and you adopt a new mechanism, we are 10 miles further ahead than we are now. So don't think about any if statements. Don't think about any compatibility. It's just that we have a mechanism that allows us to do that if we desire so in the future. And that's what Dieter is trying to say here.

**Dieter Shirley**:
No, I actually was trying to say the thing that I did want to talk about the thing that Vishal wrote. I explicitly shouldn't be talking about the thing that Vishal mentioned. And so we'll have a bigger discussion about the if statement thing and all of that business. Alex is 100% correct. Forget about that. Let's just focus on how this beacon works and how you can implement it and what configuration we need to do before it's available for people to use. Alex, the floor is yours.

**Alex Hentschel**:
Thank you. I'm gonna say something similar to what Dieter said. And since we're like having an internal group here, I'm happy to maybe, you know, talk a little bit more openly about that. So you might remember Jordan has written a blog post about this topic in March. We had a discussion with the sub-working group in like six months or four months ago, right? And we've sort of tried to move ahead with this, you know, with, or trying to share this information that there is a new mechanism available through the protocol state, which is more robust in general, to coordinate upgrades. And we'd hope that it would lead to adoption. And last week, or what Jan just said is that we have been working on the existing version beacon. And I mean, I'm sure you guys have thought well through but you all know that I'm a little bit I have a little bit of a control problem and it freaks me out that no one has talked to me because I'm worried that we're building something you know all based on the old mechanism and do throwaway work because in the long term the roadmap is to go to the new mechanism and so I don't want to make that mistake again and I want to be absolutely clear please give me feedback if you don't like that communication style or what to do better but last time I didn't get the message across so I'll I'll try to do it very explicitly the German way. This time, the old existing version beacon is deprecated as of now. So of course you should continue using it, you know, until the better system is ready. But the dynamic, you know, the new mechanism based on the dynamic protocol state, the new mechanism is not trivial under the hood, but it has been built in a way that you don't have to worry about all that stuff, right? And I believe it's easy to say, I believe it's easier to use than the existing old version beacon and it also has less loopholes. And nevertheless, there are a few aspects that you all need to understand if you're working on extending the old version beacon to avoid that you're doing throwaway work, right? Because a lot of things the version beacon will not do for you. It will help you with very specific protocol or coordination aspects, you know, which are the subtle ones. Where it's easy to shoot yourself or shoot the protocol in the foot, right? And that's where the new versioning system will help you with. So I totally understand that they probably need to kind of at least write software which is dealing with versioning, and that has to be compatible with the old version beacon, but it also has to be compatible with the new version beacon. So please, if you're working on any of that, talk to me first. And so that specifically goes to Jan, Janez, and Bio, you know, please make sure you talk to me. And most likely it won't be a controversial discussion, but I want to make sure that we're on the route of migrating both development paths, the old version beacon, the extension you're doing, and that that's compatible with the new version beacon, or the new dynamic protocol state mediated update. Okay, so that's what I wanted to say here. I think it's important to maybe talk through some of the concepts and I will repeat a lot of things what Deet just said. I have drawn a lot of pictures because I believe that helps. So please let me know if you think that's too much of a repeat. I'm happy to go faster, but I think we need to have the terminology and the understanding clear in order for us to have a good conversation, a precise conversation and make precise decisions. Okay, so what is this all about, right? That example of hashing, right? The protocol says, you know, up to block or up to view a thousand, we use SHA, and after view a thousand, we use Blake. That's a specification. That doesn't mean that the software does the thing it's supposed to do, right? There can be a software which does neither SHA nor Blake because it has bugs. There could be a software version which does both, or there could be two different software versions which do one does Shah and the other one does Blake, right? So, and that's kind of the important aspect here, right? Is that we have a specification of how the thing should behave and that can change. And the protocol state will be tracking at what block that changes or at what view that changes. And you can query the protocol state and ask like what sort of specification version Are we on? Are we supposed to use Sean, X1, or are we supposed to use Blake, X2? That's the specification. And then the software can adjust its behavior accordingly. The biggest impact that will have on practical terms is that the access node, when it goes back to old blocks, can say, oh, what cadence version do I have to use to access that state correctly? And then we can do script execution for old blocks, very old blocks, and help the access node to do that. And I know a lot of that software already exists where you say, oh, so if I know what version I'm supposed to use, right, then I can make, then, yeah, sorry, if I know what, to which specification I have to adhere, then my software does the right thing. So what we're talking about here is only how do we tell the software what specification to adhere to? Is it Char or is it Blake? That's all what this conversation is about. How the implementation will react to that? I think that's the majority of what the existing version beacon is concerned about. That will all stay the same. It's just that we're not only just having random events somewhere in the block and there is no sort of it's all left to the implementation to understand what that means right that's the current version beacon we have service events there in the block there is no protocol specification like sort of or at least protocol doesn't enforce anything about it as the software just has to know what what those events mean it has to track them completely by itself right and every instance where we want to sort of of adjust to different versions. The software has to kind of do that either from scratch, but it's not tied into the protocol. And that's what the dynamic protocol state solves here. It essentially just ties component versions to blocks. Okay. So I've already talked about software versions, right? Or Diet has talked about software versions. That's just the binary, right? It's identical for us. As a human, it's an identifier of the binary. That has meaning to us, right? So software versions, you know, I've talked about, or here we have, I've made a little image here, right? So software might have additional features for cross compatibility, right? It has unofficial features, it has performance characteristics, right? But that's all not really what the protocol cares about. The protocol cares about, says, you have to do, you have to do a certain you can do more, right? There can be areas where the current software doesn't implement what the protocol specifies because the feature is just not there yet, and we're fine with it, right? It might also specify behavior where the software has a bug in it, right? So this is just all to say that we need two notions. We can't just say software and specification is the same. Essentially, that's not good enough for us we have different nodes, we have different software, potentially different implementations, right? So we need a concept of how are you supposed to process that data block, right? And that's the component version. That's the protocol views, specification of this is what is supposed to happen with this block and all data associated with it, like the execution state. So that's a very important concept here, that for every block, there's only one right way to process that block, to deal with the execution state of that block. One right way, there's one component version per block. But the software can implement multiple conventions, right? It can, as Dieter explained, it can do SHA and Blake, right? So then the software version would support multiple component versions. And so that's a super important conceptual differentiation I wanted to go over that again to make sure that we're all aligned on the meaning of that. And it might not be quite intuitive for you to why I'm forcing you to differentiate between software and components, but I would like to ask you to just kind of accept that, that we're doing that, and make sure you understand what the meaning is. So I'll pause here and ask, is everyone good with the definition of component versus component? Software versions? Are there questions about it? Should we talk about it again? I'm happy to reiterate, but we'll come back to that concept again and again, so I want to make sure that everyone is on board with that.

**Yurii Oleksyshyn**:
Can I please just get hands up? I wanted to ask if a component version is what we have previously referred to in code as the protocol version.

**Alex Hentschel**:
So the protocol version is a relatively holistic look, right? It's just says we throw the entire protocol on one bucket and if any detail changes, then it's a new protocol version. That is acceptable, but it's a relatively coarse characterization. In practice, we do differently. In practice, we say, oh, cadence has changed. Consensus nodes, they don't care. We're only essentially we're only tracking specifications of subsystems. We're tracking on a subsystem version and that's why we're calling it a component version. So the protocol overall has many components and some components at the moment we care to version. That's important. We don't version everything because that's going to be a lot of work. We only care to version the things we feel that there's a benefit to version. Like the cadence and the execution stack, right? And the protocol state itself. That's what we've decided to version, right? Because we want to update it. Most of the team doesn't need to care about that, but most of the team cares about that cadence and the execution stack, that that has different behavior throughout the work, right? And we want to version that, and that's why we're talking about, or I would like to talk and only focus about the execution stack, right? My next step, I want to get to a point where that's also where the current version beacon is, the current version beacon cares about the execution stack, and I would like to move that in the midterm over to having the dynamic protocol state tracking the version of that execution stack, or versions. That's up for discussion, how we want to express that. I'm hoping to get to that in this meeting.

**Yurii Oleksyshyn**:
Does that answer your question? Using the protocol version, which basically commits to multiple component versions, which we define later?

**Alex Hentschel**:
Let's view them completely independently and just say, we're versioning the dynamic protocol state, that's its own component. Sometimes, if you want to change something, a different component, the protocol state also needs to change. Well, always.

**Yurii Oleksyshyn**:
We always need to update.

**Alex Hentschel**:
I don't know. Jordan, did you have something? You said basically exactly what I was going to say, so please continue. Thank you. I appreciate you jumping in and offering a differently worded explanation. I think that's important.

**Unidentified Speaker**:
Yes.

**Alex Hentschel**:
It might be good to mention that in the flip. Yes. So, yeah. Okay. Right. Agree. Leo and Janez, you are the main people who currently deal with versioning of the execution stack. Does that convention sound acceptable to you? Like the terminology of component version versus software version?

**Janez Podhostnik**:
It seems very necessary and very logical to me. I think when I previously thought about this, which was recently, I named it a behavior version, but yeah, that's component version versus software version. Yep. Makes sense to me. Thank you.

**Alex Hentschel**:
Leo, are you good? Sorry, I don't see your picture. At the moment.

**Leo Zhang**:
Yeah, makes sense. So just to clarify, cadence would be one component, like cadence version would be one component version, right? And there's kind of different component here, because cadence right now, you have a limitation that you can only run one version of this component at any time, like execution node. Well, at any block, right?

**Alex Hentschel**:
So at the moment, we only say For every block, we pin a cadence version. But the execution of DASA, that's again an implementation problem. So then we're talking about software, the implementation of the component. But at the moment, what we want to get to is to say that for every block, there's one cadence version pinned. So there's one component version if we were to say cadence has its own component version.

**Unidentified Speaker**:
Yeah?

**Jordan Schalm**:
Yeah, I would agree. Ignore for the moment the idea specifically with cadence about being able to immediately switch from executing this block with cadence one and this block with cadence two or whatever, because that's a separate difficult problem that is orthogonal to the

**Unidentified Speaker**:
versioning problem.

**Dieter Shirley**:
Yeah, I'm also going to jump in, sorry, Bastian, but I want to be really clear, because it felt, Leo, like when you said you thought component meant the software component that's running. And what Alex is talking about with this version is it's the component specification, exactly. And so a single block of code might handle multiple specifications. And so there may be a software version that can handle multiple component versions. But any given block, there is only one correct component version to both produce and consume. Which is the specification for how the data should be constructed.

**Alex Hentschel**:
We'll go through an example here. I drew a lot of pictures. I think that might help, might not.

**Unidentified Speaker**:
But yeah. OK.

**Bastian Mueller**:
Yeah, so Leo, it's basically exactly what we had already done for the security fix. One cadence software version that we shipped was able to handle two component versions that the old unfixed version and the new fixed version. And at some point it was told for this particular transaction, this block now, you have to apply the fix. You have to work in this new fixed version, like this new component version. And I agree with Jordan, like this whole discussion of how to make that possible with if statements and whatever other solutions is out of scope for this discussion here. It's more like the infrastructure and the mechanism.

**Alex Hentschel**:
Thank you, Bastian. Yeah. So I have already mentioned this, that there can, for every block, there's one component version, right? One specification of this is how you process that block and the execution state correctly. Software can support multiple component versions. There are reasons why we want to move away from the existing version beacon. I'm going to skip that in the interest of time. And I'm also going to skip the references, what the dynamic protocol state already does for versioning itself. If you want to, there are references to the code here. It might be interesting for you to look at it, but I don't want to go through that because we only have 20 minutes left. So what I want to talk about here is giving a more sort of visual example of how that will look for you and hopefully that will understand you where the overlap with the existing version beacon is and where the differences are, okay? So let's go through that example here. So we have our developer and she says at some future view, right, we want to roll out a security fix, right? So something in the execution state changes. We say, like again, I'm using the execution stack here. We're changing from behavior X1 to behavior X2, right? And yeah, so then she sends a governance or, you know, the governance committee sends a governance transaction. I think the version beacon actually does already part of that, right? We have a transaction, that transaction goes to a smart contract and the smart contract emits a service event. That's all reasonably similar, right? But the existing version beacon just stops at the service event, right? That's recorded in a block somewhere and yeah. So either you know what to do with that information or you're screwed. And that's where the dynamic protocol state will now start to help you. The dynamic protocol state will ingest that service event and it will track what the current component version is at every block, and it will track at which view a change to that will happen. So here in the beginning, the dynamic protocol state says, at the moment, we are running execution stack version X1. Every block has this information. By the time the service event here is being sealed and finalized, the dynamic protocol state will say, oh, I guess we're still at the current execution stack version X1. But at a future view, that execution stack component version will change to version X2. So the dynamic protocol state will just record that in the block. And then when that view comes, or when we're exceeding, reaching or exceeding that view, that specified view, then the dynamic protocol state will automatically know that, oh, we're now at that new block, now that schedule change takes effect, and it will report that as of this block C, the current execution component version is X2. So here you see it has changed from the blocks which are smaller, have views smaller than specified view will report for themselves the old execution stack version, X1, and then any block at view or larger will report X2 as its component version, and you will have a very clear API. You can already ask the dynamic protocol state, hey, what epoch are we in? All those APIs you probably work with occasionally where you can get information about the block, what epoch it is in, what the consensus nodes are, what other nodes are permitted, who is joining, leaving, staking, you know, are we staking, are we in epoch setup, are we in epoch commit phase, you know, that's all the dynamic protocol state. It tracks information about the block and it does that in a Byzantine fault tolerant way and it takes care of finality. That's a super important thing, that's why we're using the view here because we don't want to run into the scenario where we have two forks and then we have to switch forth and back. Yeah, so we, you know, because some changes do not allow us to switch forth and back. And so that's the reason why the dynamic protocol state uses a view. So you will have this very clear API, which just, you know, you can say for this block or for this finalized height, which then immediately maps to a block, you can say, hey, get execution stack version, and it will give you something. I have just written down uint here, but that's up to discussion. You tell me you want, I don't know, some version, you want the string, we put in there whatever you want, right? I'm just using uint here as a simplified example, and you can ask it, hey, what is the scheduled version upgrade, right? So at which view will the current execution stack version change? Now it can be a string too, happy to use a string. So it will tell you if there's a version upgrade scheduled or otherwise just say new, no version upgrade scheduled. But you will always get that information for every block, what is the execution stack version? And then I think that's very similar, the implementation of that component has to know, can I, do I support that specification? Shah versus Blake hashing? Can I do either and make the decision whether it can sort of fulfill that function call or it has to error? And so what, yeah, right. And what I would like you to think about is, you know, this interface, you don't have to worry about much of this here. You know, Jordan, Yurii, and I will be taking care of that, all the things related to dynamic state, but you guys have to tell us how you want to version your execution stack. Okay. So, yeah, there's an example here. Take a look at that. I think, I hope that's reasonably self-explanatory. Deet, I've used a different naming here, right? You called it instant upgrades. The upgrades, I think, you know, I mean, maybe they're instant, right? That can be, but I think that's not the critical thing. The critical thing is that the node operator right? We can do upgrades, like I think Leon and Janez have implemented that for the execution stack, that the execution stack does that. It can say, oh, you know, you can roll out the upgrade. The upgrade understands how to do the old convention and the new convention, the old component version and the new component version, right? And then at some trigger, it switches over, right? So for the node operator, that's a hand-off upgrade, right? They don't have to jump on a call with us. In some weird time zone, they don't have to bring their node down. It's essentially a hands-off upgrade. That hands-off upgrade might require a reboot. It might take five minutes. That's the reason why I'm not necessarily sure that's an instant upgrade. It can also be a non-instant upgrade. But what's important is that the node operator doesn't have to sit in a call with us. But happy to use instant upgrade if you want to use a different terminology. I just want to say that I think that's a huge benefit. And Leo and Janez have already implemented. My understanding is that with the component, with the version beacon, has implemented that on the software level. I just would like to get to the point where we're using the dynamic protocol state to coordinate that all. So I don't think that's a huge change for you guys, but I want to make sure that we're working towards that change, using the dynamic protocol state to track all that. Thank you, Janez.

**Janez Podhostnik**:
Please jump in with a question. I have a few questions. Let's see. Let's start with, if I want to get the component version in, let's say, execution, do I do that by reading something on the chain or do I do that by injecting it from somewhere?

**Alex Hentschel**:
That is a beauty. From your perspective, you don't have to worry about any of those details. Here, this is the API. If you go into our code base and go into the protocol state, the packaging has inverted has changed the naming. So that's here, you know, protocol state, right? And the protocol state has a KV store in it.

**Jordan Schalm**:
I think, Alex, I think Janez is asking a different question, which is access from within a cadence smart contract. Is that, is that right Janez?

**Janez Podhostnik**:
Yeah, so yeah, the Virgin Beacon is currently from the cadence smart contract. So what the FVM does is it reads that version from the smart contract and passes it to Cadence. If I understand Alex correctly now, I basically just need to inject this interface into the FVM instead of reading a value on chain. Yes.

**Alex Hentschel**:
The problem is if you read a value on chain, let's say we make a breaking change and we change how you deserialize the execution state. You need to know how to deserialize the execution state before you can read anything from the execution state. You know what I mean? So, you know, reading the information, you know, to determine how to deserialize the execution state from the execution state doesn't really work. Or it doesn't generally work.

**Janez Podhostnik**:
Does that make sense? Yeah. Okay.

**Unidentified Speaker**:
I also just have a list.

**Bastian Mueller**:
Please keep going.

**Janez Podhostnik**:
Okay, so right now we were using a software version and component version as the same number generally. We didn't actually have a concept. We didn't actually need to use a concept of a component version because we always had them in sync. But does it still make sense to sort of keep them in sync so that the latest component version that is supported is the software version?

**Alex Hentschel**:
I'll give an answer and then I'll let Jordan answer that question. I'm sure you probably has a more refined answer. So, you know, that concept breaks down at the point where we have a software that implements multiple component versions, right? Then, like, okay, we can say we use the latest component version to reference the software, but that still doesn't tell us how many of the past component versions it implements, right? So I think that's where it And that's why I think the software needs to enumerate and say, I explicitly support version X1, version X2, version X3.

**Unidentified Speaker**:
OK.

**Janez Podhostnik**:
That makes sense. But that was part of my question. But the question was also, Right now we have, I don't know, FVM version 0.39 or whatever. It doesn't matter. Would we also set our component versions in a way so that the latest component version that's supported by that current FVM is 0.39, but it also might support previous component versions. I'm just asking about the naming. Should we name our component versions in sync with our software versions to make it easier or is that more confusing?

**Alex Hentschel**:
I think that's a recipe for shooting ourselves in the foot. Just decouple it mentally. There will be instances where a lot of times the software says, I only support one component version. That's great, right? But if you sort of have the mental mindset that we have some sort of coupling, I think that's the recipe for disaster.

**Unidentified Speaker**:
Yeah.

**Dieter Shirley**:
And I'll just jump in real quick, Jan, is you can imagine that there's a software version that has an internal only optimization, right? It's a new software version, but it doesn't impact how it interprets messages or anything like that. Maybe it, I don't know, it has a new memory allocator. I don't, I can't think of an example on the fly, but like critically, you could imagine internal algorithm that produces the same output that has been changed. Maybe it's just a refactor. And that's a new software version. But the protocol, the input and output haven't changed. And we need to be able to track that it's a different software version. And we wouldn't want to boot bump the component version, because now we're creating more bookkeeping. And so I think that we should decouple them entirely.

**Unidentified Speaker**:
Yep.

**Jordan Schalm**:
Agree that we should decouple. Couple of them. I just wanted to go back to the question about how we define a component version and to point out that we care about the component version in an extremely specific case, which is exactly when there's a breaking change, kind of like what Dieter said. If there isn't a breaking change, we don't care. Change whatever you want, right? So for me, that's a very, very strong indication that we should not use simpler or more complicated versioning mechanisms, we should just use integers.

**Unidentified Speaker**:
I'm a plus 100 on using integers.

**Alex Hentschel**:
There's a discussion on here. If you want to read up on it, we probably won't go through it. Yeah, just saying, look at the docs. Go ahead.

**Unidentified Speaker**:
Yeah, maybe.

**Janez Podhostnik**:
I have another question, but maybe someone else can go first this time.

**Dieter Shirley**:
I think it's Bastian's turn.

**Bastian Mueller**:
I also just have a list of questions that we can take turns. The first one, I think I haven't read the document too much, but in our discussion yesterday, I kind of assumed that the interface was like, you know, I told Alex that I want to have like some component that's called cadence and I want to get the the current cadence version, right? What is the version that I should be executing as? And then is there documentation around that interface? Because there are two functions and how are they used? GetExecutionStackVersion, you don't pass a component name? I'm sorry, Bastian.

**Alex Hentschel**:
This was just an example of how it could look like for people to get an idea of what we're talking about, right? This is not implemented. This is just the most basic example I could think of You want something different? You want a cadence version and an RPM version? All good. This interface is going to look different, but the conceptual functionality of, I have a current version of some component and something in the future can change, that will remain the same. That's the only thing I wanted to illustrate here.

**Bastian Mueller**:
Because you asked, does that interface work for you? And my question was, what is that interface and how does it work? And you say, oh, this is just an example. You won't have to do that. What is the interface? What is the interface that I get at the most? The proposal says, here is a mechanism. What is the interface? Of that mechanism? Is it like, I can ask it, please give me current blocks component version?

**Unidentified Speaker**:
Yes.

**Alex Hentschel**:
So the interfaces, you specify a block, right? The same way as you ask for a block, which epoch does it belong to? Right. But yeah, go ahead.

**Bastian Mueller**:
No, I'm just like, because the interface doesn't look like that, right? Like we were saying, we just said, like, I asked, like, oh, do what is the interface? And he said, like, I can ask it for a name, cadence component version, and it gives me the version, the current one for that. And if I look at that interface, it's something else. And I wonder what that other interface is, because I don't fully understand it.

**Dieter Shirley**:
Can you bring it up, Alex? Can you, like, can you bring up the code that is the literal interface that you're vending?

**Bastian Mueller**:
Or is it like, maybe that should be part of the proposal? Maybe it is. And again, I haven't read it fully in detail, but I was just a little bit confused about about how, like, you sort of asked into the room, like, does that interface work for you? And I wondered, like, how to use it. Sort of for everyone, that's maybe one point. Yeah, I have that strongly simplified here, right?

**Alex Hentschel**:
Because, like, you first have to specify a block, and then you get all the meta information from the block, and then you can query the meta information, right? And this is one of the query methods for that meta information if you've already specified the block. I'm trying to find that here in the background.

**Bastian Mueller**:
It would be name-based or something. I could say like, hey, what is the cadence component version? And hey, what is the, I don't know what other components there will be, but, right? That's the idea.

**Alex Hentschel**:
Yeah. Yes. Yeah. That's, that's, it's name-based. Exactly. You know, so there's, for each component we agree to version, there would be two two functions in the dynamic protocol state, right? And here at the moment, I've just used execute. Can you see that? My marking here on the screen? I've just, you know, I've just like literally set as an example execution stack version, right? You can also say, no, I don't want to version the execution stack as a whole. I would like a version for the cadence. Then we would say get cadence version. And then it gives you, you want to use you want semver, you want the string, anyway, just tell us, right? But the process is always the same. The same as you can go in the code and ask a block, which epoch do you belong to, right? So you say block by height or block by ID, you feed in the height or you feed in the ID, and then it will give you a secondary interface, right? The interface for creating all the meta information. And that meta information has something like, oh, epoch, right? Epoch counter and which Epoch phase are we in, right? And among those methods would then be two additional methods which we would implement for you, right? Which would be get execute or get cadence version, you know, get cadence version upgrade. If we want two version numbers, right? One for cadence, one for FBM, we would have those two message for each of those, right?

**Bastian Mueller**:
I get the version because that's what we discussed, but what is the upgrade one?

**Alex Hentschel**:
That is what the protocol state knows. When the protocol state knows that there is a change scheduled in the future, right? Here, our developer says, if you want one million, I want this version to change from X1 to X2. That information will eventually make it into the protocol state via a service event, right? Then the protocol state will be able to tell you for a future view, you know, this year, the view-based activator, someone will need it.

**Bastian Mueller**:
But like, I think for, for example, for, for many components, only the first function would matter. What is the current thing I should execute? They might also happens in the future, but probably won't care. I mean, I see now.

**Alex Hentschel**:
It's maybe a boot up, right? You know, it boots up and sees, Hey, in a hundred views, right? There's a version came scheduled. And then the software can ask itself, do I support that version already? Otherwise, I might want to print a warning message for my operator to be like, hey, dude, in 100 views, I won't be able to make progress anymore and I will get stuck. So you're right. Most of the times, we don't care about that.

**Bastian Mueller**:
But just in case you care, that information is in there. So that was my first question, but we are taking turns.

**Leo Zhang**:
Yeah, I have a few questions. I'll start with simple ones. For example, if I have a component that doesn't support the view from which the feature is activated, and then the component should probably say, or have the right to say, let's stop, right? Because I don't want to continue on the future view, for example. I don't want to use this cadence when I need to execute the next block.

**Alex Hentschel**:
OK. Exactly. That would be the software, right? I think I said that already, just let me make sure I say it again. That's the logic you already have as a version beacon, right? Your execution node implementation says, hey, I can't do that version, right? It's just that now the mechanism for how we track what's supposed to happen, it will be part of the dynamic protocol state instead of just being somewhere in the service events. That's the only change here.

**Unidentified Speaker**:
Right.

**Leo Zhang**:
You guys have hands up. Go ahead. I'll continue my question later.

**Unidentified Speaker**:
Just in the same vein, how?

**Bastian Mueller**:
Like, how would I then, like, I can get the current version if I know that I can't? And what is the mechanism to tell, no, I can't, I need, executioner needs to shut down or whatever?

**Janez Podhostnik**:
We have that mechanism on the execution side, but we don't have yet on cadence side, because we kind of assume that there's one version that both FVM and cadence use. So if we want a separate version for cadence, then we would have to add that logic. If we just want an FVM version, just one version for FVM and cadence, then we just have to update control or the logic we currently have for version beacons.

**Bastian Mueller**:
But I think that was like, sort of, you tried to explain it for the FVM and cadence situation. My question was a bit more general for that whole mechanism here. Like, if you look at the interface, it just says like, what's the current version? For one specific block, right? I get a particular block with my software version and I'm not able to do this component version anymore. Then what? How do I communicate that to the... Well, the components sort of... Maybe the answer might be, well, each component needs to decide it on its own. If it can't do something, maybe the execution node, it just shuts down. The consensus node should, I don't know, lock something or I don't know what it would be. But that's not how to handle that a component is unsupported by the current software version that is out of scope?

**Alex Hentschel**:
That is part of the implementation, exactly. The dynamic protocol state only says you have to process this according to convention X. And then the software can either say I can or I can't and react to this, I can or I can't, and do its thing, crash, crash loops, things like that. There's a little subtle aspect which might be worthwhile mentioning. But before I do so, I want to say I'm happy to stay as long as you want. I have the next hour free. But we're over time, so I just want to make sure that people who want to participate have a chance to, and I don't just extend this meeting and you guys screw up your calendar.

**Alex Hentschel**:
Okay, so we just keep going.

**Peter Argue**:
I got a few minutes, but I can stick around for a bit.

**Alex Hentschel**:
Okay. I wanted to say that, you know, there is an implicit assumption that when you bring up a node, right, or when you bootstrap a node, you know, that information will be also part of the dealing segment, what we bootstrap the node with, right? And we assume that the software kind of, you know, understands or, yeah, at least that convention that's part of the seeding segment, right? And from there on, it will sort of get new blocks and track whether it supports any version change or whether it can do any of the specified changes of conventions, you know, when it gets new blocks. But we, of course, initially assume that you bring up a node with at least the software that supports the seeding segment. Okay. Leo, I think you had your hand up.

**Leo Zhang**:
Yeah, I think this approach is based on the view, right? So if we are going to, let's say, process a message differently based on the view, let's say from view 100, I'm going to process it differently with that version. That assumes that we know the view of this message. And what if we don't know the view of the message, or it takes additional effort to do that. For example, execution node needs to fetch collection to execute a block. And the collection only have the collection ID. I don't know what block is it for. It's just to have a collection ID. I don't know what is the view for, even. So if I receive a collection and we change the way to encode, even, the collection that say, I want from block 100 onward, I want to use version B of the encoder or decoder of the collection message. And how can I utilize this if everything is based on view? That's a good question.

**Alex Hentschel**:
Deet asked that yesterday too, and I gave him the Deet answer, you know, which is, so at the moment we use height, right? That's an existing version beacon that uses height. I would argue that if you have access to height, then you also know the view. I don't think there's really a scenario where you know the height of a certain thing, but you don't know the view. So with that in mind, I don't think the existing or the dynamic protocol state tracking of versions is more restrictive. Because instead of height, we're just using view. But you're absolutely right that there is a very small case or group of scenarios where we don't know the view, right? Like for instance, if you change message encoding on the networking layer, right? That's not, that thing is not gonna solve it. You know, the dynamic protocol state, neither does the existing version beacon. But I think this scenario, group of scenarios is relatively small. And if we already solve the upgrade make or not. But make the upgrade mechanism better and more robust in the scenarios where we have a view, I think that's 99% of the cases, then we're already a lot better off. We don't need to make the solution perfect. We can think about that scenario later, but you're absolutely right. And I'm glad you flagged it that it won't solve everything. Good. All right. Thank you. Next question.

**Janez Podhostnik**:
I have a question about the current way we do ATUs, so the stop control component that's using version beacon and sort of resourcing. We didn't, to my knowledge, there's no time allocated to upgrade the stop control to the dynamic protocol state. Is there an idea of who will do that? When will that happen?

**Alex Hentschel**:
When should that happen? I like that question. Thank you for asking it. My approach in a lot of those areas is that even if we haven't directly allocated time, there are cases where we work on things despite there not being explicitly an OKR for instance. And I think, wasn't that something similar to, I think you and Leo, you worked on the existing version beacon like the last week. I don't know if you had an OKR goal on that, but it happened. And there was good reasons why it happened. And the only thing I want to make sure is that the work we do is compatible with the roadmap. I'm not saying you guys have to pursue the roadmap. I'm just saying, if you're anyway touching that component, please, or that implementation, please touch it in a way that also sort of furthers our roadmap. And maybe it's not five days, maybe it's six days, but at least then the solution can carry over as opposed to needing a large refactor. And that's my only intention here. And that's kind of why we keep talking about it. And that's why I'm kind of pushing you a little bit. Because we, you know, we want to make sure it's compatible.

**Peter Argue**:
I would add to that too that over the summer we built out a system that kind of bridges the gap between the dynamic clinical state and the version beacon that we use for the access nodes for dealing with kind of the cadence versions. And the way that that was designed was intentionally to make this transition simpler. So there's probably a pathway where we move execution and verification over to using the new system the access nodes are using to make it like a fairly straightforward port. I know you've reviewed all the code. Obviously, there would be some time to spend to validate Thank you, Peter.

**Alex Hentschel**:
I also wanted to highlight that I really appreciate Peter has continuously bugged me about that since we had that conversation five months ago. And I really appreciate that because I know that at least what Peter has been involved in will be compatible with the new dynamic protocol state sort of versioning. And what I would suggest is this is all very abstract. And I see that it's hard for people who haven't really worked on the dynamic protocol state to kind of envision how that's going to work in detail. So my suggestion would be that you guys tell us how you want to version the cadence and FVM, one version, two version, integers, semver, whatever you string, whatever you want, right? You tell us that and then we'll build you that interface that you can just go each block just get that information out. Then at least you have a point where you can kind of see the code and see the interface you have to work with. For Jordan and Yurii and me, that won't be a huge amount of work, but I hope that will be a little bit of an unlock that that work becomes more tangible for you. And then you can look at the new interface and be like, oh, OK. If you were to switch over to that dynamic protocol state interface, stuff I'm implementing, is that compatible? That's what I'm hoping to contribute here to further this endeavor. Is that good?

**Unidentified Speaker**:
That's good. Got you. Go ahead.

**Bastian Mueller**:
Brings me to my next question. Nice segue. Yesterday, we talked about how to define these component versions. And I know that in the current implementation, just for comparison, you know, I'm not saying you should do it that way. I'm just saying like, currently, with the mechanism that we had on the cadence side, like for the cadence component, we're able to just sort of on the fly say like, hey, there's like now a component version, and it's called cadence. And it has this version in a sense. And then you said yesterday for this mechanism here, the process is that each component author needs to tell you or needs to tell the protocol team that there is a component version and then it gets sort of hard-coded, right? Like that's why I was so confused looking at the interface for me. I thought there would be sort of some kind of dynamic naming I can just assign for some component that the protocol is unaware of, but no, you said like it needs to be hard-coded inside of this protocol and there will be like one function or like two functions because like current and version upgrade per component and it will be like hard-coded. Is there like a particular reason for that or like a limitation? It's just a process that you want to make sure that this is like all well-defined and hard-coded because the problem with that is that every time you want to introduce a new component version, you first have to do an HCU. And that seems to be a big problem from an operational perspective, like listening to Vishal every time you want to ship a security version fix. That's been a problem. That is a very good question.

**Alex Hentschel**:
So I wanted to say that in order for us to upgrade that, we don't need an HCU. We don't need all the node operators to sit in a room at the same time, bring down the nodes, and boot them up with a new version. That would be exactly the same mechanism. We tell the node operators, hey, within the next month, please roll out that new software at any time you would like, and that new software will support the old dynamic protocol states And we'll support the new dynamic protocol state with those methods. And then we have a, you know, view-based activator where we say, okay, the actual sort of the information we tracked per block, let's say up to view million, we didn't crack cadence in the dynamic protocol state. Effectively from a view million, we will track the cadence version in the dynamic protocol state. Operators can roll that out at any time, you know, a month before or a week before. And the dynamic protocol state will ensure that nodes who haven't, don't have the new version that will just stop working. So, you know, so I don't think sort of from a node operation perspective, that's a huge deal. It's kind of actually already using what Deep described as instant updates, right? The hands-off node operator updates. But you're right, that for us, each time that's an explicit code change. I'm wondering, Jordan, you brought up your hand. Do you want to describe why that is the way? I'm also happy to talk about it. But if you want to explain that, I'm happy to.

**Jordan Schalm**:
I don't think it's that important to describe why. I think it's more important to just say that that's the way it is. Those HCUs are simpler than the current HCUs that we have. So adding a new field is less of a hassle than it otherwise would be. The other thing I just wanted to mention related to your question, Bastian, is In making this system the way we have, we have assumed that we will have very, very few component versions. Personally, I think two is probably the right number, frankly. I think we should be very cautious about introducing a ton of component versions. So that's part of the reason for why they're statically defined. Maybe we're wrong about that, and maybe we and we can kind of reconsider the interface, but that's where the kind of static definition of each component comes from Thank you, Jordan.

**Alex Hentschel**:
I would like to add on to this that, you know, we've just introduced that mechanism, and the last thing we wanted to do is over-engineer it, right? So if we learn in six months that we actually now have 10 versions, you know, introduced 10 versions, there's a huge need to add new ones, we can refine it, right? But sort of in building the foundation for this entire mechanism, the easiest was to just say, okay, for initially just let's work with, you know, with static method names. And also the most secure, right? Because then there's, you know, it avoids a lot of code complexity. And so I'm not saying that, or I appreciate you sort of thinking ahead. I'm just saying that's also learning thoughts, right? And we're very happy to refine and sort of extend this mechanism and make it much more easy to introduce versions. But for the time being, this is sort of, we try to not over-engineer it, period.

**Bastian Mueller**:
And that's the reason why it's now authentically defined. Yeah. Just for context, interesting that you mentioned that number, Jordan, because, you know, I think that's sort of one extreme. There will be very few, that might be just two components, right? That's sort of where we start out with. Then the discussion, you know, just thinking about that myself, like for one particular component, as an example, would be like cadence. And even there immediately, like, I'm thinking, oh, we have three different components in its own. We have like the language version, we have the execution state, we have the encoding for events, we even have the encoding for arguments and return values, but you would probably say that all of these would be even they're already separate components, and I could, for some of them, tell you upfront, and for some of them, I could probably not tell you upfront because it didn't occur to me. And then suddenly there's a security report, and I'm like, oh, damn it. This is actually component version. This should have been a component version. I want to introduce it. Oh, we can't because it's sort of hard-coded. I think it's, and then to add to that, there was the other extreme on the other end. I don't know if Dieter is still here. I think he left, but yesterday he said like, oh, I think we should start with as many component versions as possible, right? It's the exact opposite of how this was designed. And I'm sort of in the middle ground, sort of asking, hey, there should be probably like a few, I don't know quite upfront what they will be, but I will for sure, will tell you in a few months from now, hey, that needs to be another one. So I think maybe that's something we need a little bit more discussions on. And Alex, I think that was also you asked how I understood you yesterday. I think you wanted to know from all the teams what should be the components and what, right? No, that's not part of this anymore. Sorry.

**Alex Hentschel**:
I would like to focus only on the execution state for now, right? Or the execution, because we have a version beacon, right? We have one version beacon at the moment, right? We don't have 10. We have one version beacon. So let's at least transition that version beacon to the dynamic protocol state. So it becomes better, more robust, and sort of, you know, because then we already have two. And like, by all means, you know, the only reason why we don't have made that more generally applicable and more generally or easier to add versions on the fly is because you didn't want to over-engineer it.

**Bastian Mueller**:
No, I totally get that. It's definitely great to hear that you wanted to keep it as simple as possible. And the only part there is sort of, I don't want to say it's limiting, but it seems very, you know, flexible isn't the right term. But you know, we have to sort of ship the definitions for the components through a software update. But we anyway have to do that.

**Jordan Schalm**:
Sorry to interrupt. I think your concern is like, oh, there's an urgent security problem. I need to make a software update. But I didn't think of the component that it affects in advance.

**Unidentified Speaker**:
Yeah.

**Jordan Schalm**:
And I think that is a concern if we have like really intelligent No downtime kind of sorts of software updates where like the kind of beat was talking about where this software understands this specific chunk of the Specific component and I can do it in version x and y we don't have that at the moment at the moment what we have is we we reboot and we start a new software version, and all of the components potentially can change, right? So that's the mindset I would use for this, and that's also why we are kind of starting from that more coarse-grained versioning approach, is because we have kind of blind instruments for versioning, so a coarse-grained set of versions makes and fits better.

**Bastian Mueller**:
Yeah, I think the answer is probably that we will get to that at some point and probably that my concern or my question will be answered at that point in time, like how we deal with that. But thanks for giving the context why it is the way and why it was designed that way.

**Alex Hentschel**:
I also wanted to mention that I think we're limited in the frequency because each time we're saying this component can now independently update, In any case, that means that node operators have to deploy a new software. The old binaries won't understand the new thing. We can't know the future. So each time the node operators will need to deploy a new software, and we want to give them a decent amount of time so that they are not under pressure, or at least in most cases. And so I think that already limits frequency. And if we do it every week, well, a year only has 52 weeks. And if every week we have a new component version, we can also just say, okay, well, next month we're going to introduce those three new versions for those three different software components. At least that's my gut feeling. And I'm not sure if that's going to work out, but that's sort of the thought also behind that we won't be adding new components The new version numbers or new version, I guess, identifiers, I don't know, won't track new component versions many, many times a week or something.

**Leo Zhang**:
I think next is me. I think the version here serves two purposes. It's so that for Node, that not upgraded yet, we are able to control it so that it will be forced to stop before a certain feature is enabled, is activated. And then it also serves a second purpose, is so that if you do have upgraded, and then you pass set height, and you are able to understand your old behavior before the point when the feature is activated. So however, the version is just a number, an integer, and keyed by a certain feature. But when we need to control the behaviors, we kind of think of it as like a feature toggle. So if we want to support all the historical behaviors at a certain height stuff, if we get a message in the past and we need to process it in a way that is based on the spec in that height range. And we need to know, at that viewpoint, what is the logic that I should be following to that view. I was thinking, we might need a certain translation between view and the feature toggle. If we want to be backward compatible forever, let's say, for a long time, if there is such feature and be able to support all historical upgrades. Let's just say we change the block hash, right? And we say we want to support all the block hashes from all different heights. And dealing with heights is kind of, I don't know, it's harder than dealing with feature toggle. If you tell me, like, I have three feature toggle, and this is on. All of this is on, it's much easier to look at these feature toggles in the logic. So I don't need to deal with eye directly. I just need to deal with toggle. I wonder if that makes sense, and if this translation from view and toggle could be abstracted. And where should this live? Is it lived in the, like we do have this translation right now when we say when we implement for cadence translation, for cadence upgrade. We literally built a thing that translates this so that if you didn't upgrade, you will stop at that height. If you upgrade it and you know your future toggle will be enabled at block 100, then before block 100, your toggle will be off so that you behave as if the same as those who didn't upgrade and everything is consistent. And after the point that you activate that height, the toggle will be on. And then everyone gets a consistent state. And in the future, you can even get rid of that feature altogether and always use the same new feature so that the new feature is also consistent with those who has a toggle on. But if we want to always support it, and we probably need to deal with the feature toggle, which would be easier than dealing with virtual.

**Unidentified Speaker**:
I would say it's the same, actually.

**Yurii Oleksyshyn**:
Dealing with the version is the same as dealing with the feature toggle. I don't see any difference between them. If you're dealing with the views or, well, with a system based on views and height, you still get the same property that you will get one value at view X and one value when the upgrade happens. So your feature toggle, as you said, you can implement it in a way which compares the current version to the desired version. And you say true or false, feature activated or not. So it's essentially the same.

**Alex Hentschel**:
Maybe a way, I agree with exactly what Yurii said. I would maybe try to give you an example of how you could implement it. I don't know if that's is that smart for Cadence? So imagine you have a table, right? And each column is a feature toggle, right? It's either on or off, right? Feature is on or off, right? And so, and then we, so like, can you give me an example what feature you activated so I can make it more concrete, Neo? Like what was the last feature toggle you used?

**Leo Zhang**:
Yeah, Bastian just mentioned like Cadence has three components, right? And each sub-component could have feature, let's say, upgrading this feature.

**Alex Hentschel**:
Okay, so we have three columns then, right? It's component A, component B, and component C. Then we go through block by block, right? Those are all rows, right? And so for each row, I would say, okay, is this component, like component A, is a feature toggle on or off, component B is feature toggle on or off, component C is feature toggle on or off, right? If you just number the columns, You have a unique identifier, and you can say, oh, this sort of specification feature toggle A is on, feature toggle B is off, and feature toggle C is on again. That's version 1. And then version 2, I don't know, maybe feature toggle A switches, flips, or something like that. So you can make that mapping. You can put it in the dynamic protocol state if you want to. Then you just have three subcomponents, and you kind of, you know, say version 0 is feature toggle off and version 1 is feature toggle on. You know, you can also just do that in the software, right? And say, okay, we're having one version describing all three of those feature toggles, right? And we're just, each time we're changing that, we're just incrementing the version. So you can express it at different levels, the way you desire, either on a software level, you know, and say the specification only says version 1, and the implementation knows, oh, version one means feature toggle A is on, feature toggle B is off, and feature toggle C is something else. Or you directly express that in the protocol state. I think that's more sort of, that's more based on how you think your usage pattern will be. And that's why I'm kind of pushing and asking, hey, please give us that information, right? Is it cadence version one version, cadence three versions? Do we version FEM separately? Do we version the entire execution stack together? I don't know. I can't tell you. I'm just saying you can do everything you want to like that way.

**Bastian Mueller**:
Yeah. And maybe just to jump in, Alex, but I think Leo was literally just giving an example, right? He said like, look, for the component version, for the component cadence in the past, what we've done is we realized that it's much easier to work with feature names and feature flags inside of the component that's like one particular scheme you could use because it's much easier to reason about feature names than about versions, right? Like if you look at the Ethereum code base, they do that purely on, they give like the, I think they even give the block heights when the switch over is names, right? Like they say like, oh, I don't know what the reason one was like they have city names or something, but still all of the code is based on versions. At the end of the day. And that's, I think, quite confusing or not really easy to reason about. If in your component, you just have feature toggles, then it's much easier to reason about that one single feature flag than it is about some kind of version that's defined currently. That was, I think, what Leo wanted to say and give an example. And it's up to each component to choose what they want to do. But it might make sense to, I don't know, help component authors with that task, right? Eventually you will end up in a state where you probably have to support many component versions. Like in the security fix, it was very simple. We only supported two before the fix and after the fix. Simple enough. Point in time you will probably support, I don't know, 10 different component versions. Do you want to have your code cluttered with like if statements that have if version so-and-so, if version larger than nine do this, compared to like just having feature toggles that are flipped on and off based on the version. So I think yes, at the end of the day the behavior is the same, but I think there's like, I wouldn't call it like a best practice, but like a recommendation for how you could, if you want to handle that versioning problem in your component, might be helpful, you know? And Leo just gave an example how to make it more manageable along, maybe, sorry that I'm jumping ahead, Janez, but it was very, my question was very related to that. You mentioned before that, for example, that coupling shouldn't be to the software version, right? Like that's kind of like related. Maybe it might make sense to put that into the flip, like not like things that are part of the protocol, but a recommendation on how to use it, how to deal with it. So that there is also maybe some kind of consistency between the components. Oh, the cadence component, they use features Oh, the protocol, they do it completely different. And, you know, it's sort of the wild west of, if there is like a good scheme of how to do that, might be worth like recommending it. I wouldn't say like prescribing it, but everyone will have to deal with that same problem. And finally, related tracking of all those versions, right? Like I, at some point, again, we will have many, many decisions versions. On the Caden side, again, as an example, we have introduced, I don't know, three different security fixes just last month. Theoretically, that's a component version each time. And keeping track of exactly what component version enabled what feature in the language, for example, like that it now behaves with the security fix enabled, is going to be like a sort of organizational nightmare. We already have that now it's going to be more complicated because we want to make every software version support multiple component versions. Again, it might make sense in the proposal to sort of recommend or maybe in the flow team, we kind of agree, hey, we use GitHub. There's a markdown document that's called changelog and we keep track of all the versions and what they mean. I'm really worried that like all the component authors and the team will just sort of do different things and it will be sort of not chaos, but hard to keep track of things if you want to keep track of things.

**Alex Hentschel**:
Yeah, let me, I would like to respond to that and then I'll hand it over to Jordan because I have the feeling he has also a very good answer to this. So first off, I completely agree that for sometimes it might make sense to have a feature toggle, right? And if you want want like the UN can also just be a bully, right? That is literally a feature toggle. So on the one hand, but on the other hand, I want to explicitly also warn, right, because you've kind of explained Ethereum and said, hey, you know, what is if you wanted to do it like this Ethereum? And I wanted to also say that it is, I think, well understood in the community that Ethereum solution is actually has also severe problems, which is that the software is littered with if statements. You know, and that is, I think, and I think that is exactly one of the reasons, you know, that's specifically the concept of feature toggles, right, that comes from there. And we explicitly don't have that in Flow, except maybe for the access nodes. Because in Flow, you know, you don't have to be able to, as a node, you don't have to be able to process a long history, right? You only have to understand what's currently going on and what was going on in the last epoch. And so, you know, and so, and so, you know, instead of saying, okay, now we're introducing a new feature flag, you know, that feature flex, which is on. And then after a few weeks, you know, the, the feature flag is always on and we're removing it again. You know, why don't we just like, you know, I think it's, it's a lot less sort of Software complexity. If we kind of roll that into versions, right? Because it automatically sort of forces people to think about, Oh, at version one, this feature sort of came in addition, right? It's similar to a feature toggle. Now version 2, that feature came in addition. We have rarely the case, right, where it's, oh, you know, if feature 1 comes in Epoch 10 and feature 2 comes in Epoch 12, we rarely have the case where we have feature 2 on, but feature 1 off. You know what I mean? It's always, it tends to be additions, you know, and I think that is a relatively prevalent pattern. And And I'm not really sure that sort of, you're right, that doing it like Ethereum would not be easy in this expression, but I also don't think it's, I don't think we want to make it easy to do it the Ethereum way. Because, you know, for the exact reasons, those downside of the code being littered with if statements, And in the end, I don't have a good solution or I don't have a good proposal what sort of the best practice would be because we don't have enough experience with this type of versioning. I think in one year or maybe in six months, we can do a best practice, right? But at the moment, I feel more like, hey, do what makes it easiest for your code, for your component, and version it the way you like it. You want feature toggles and use Boolean. You want unify it. Because at the moment, the only thing we can do is speculate. So that's my two cents here. Jordan, do you want to respond to Bastian's question too?

**Jordan Schalm**:
Yeah, you covered a few of the things that I was thinking. One thing I just wanted to mention is that feature flags are potentially a good way to do this. Two points on that. One is like Alex was saying, I don't think we want to immediately start having a feature flag that can be turned on and off, or a software version that can handle every single possible component version forever, going forward, starting now. I don't think that's feasible. We're going to continue doing HCUs, and that's going to be a restart of the execution mode. It's not going to be backwards compatible. I just don't think it's feasible. To immediately switch to making everything if-else statements for every feature, which is kind of incompatible with what Deet said, but that's my two cents. And the other thing on the topic of feature flags is, for me at least, there's still kind of a layer above that that would be needed, even if you describe your compatibility with a set of features compatibility, which maybe is like the addition of a feature flag. Maybe you end up just having another version number, which is like, here's the version of this set of feature flags. And then after that point, with the same set of feature flags, you can kind of turn them on and off at will. So I do think it's important to note that there's still that notion of being to know whether or not you're even compatible, which might be better suited to a version number. Yeah, I think that's all.

**Unidentified Speaker**:
Go ahead, Janez.

**Janez Podhostnik**:
Yeah, the question I had was already answered in the last section.

**Bastian Mueller**:
Sorry, I forgot to put my hand Sorry, I just did a follow up to that. Thanks for explaining that. And maybe it makes more sense to not use boolean feature flags and just think about additional new things that were introduced in versions. But in general, my feedback was more from an organizational perspective. I think at some point we will start using these versions We already did last week for the security fixes, and there in particular, the idea was also that behavior of supporting the two components would be temporary. At some point, quickly, we want to get rid of those feature flags or version-based branching to clean up the code base and say, no, no, this software version now only supports the new component version, not also the the old one. It was great that it was supporting the two versions because then we could do a rolling update. Theoretically, we weren't able to, but theoretically in the future, we'll be able to use that mechanism here to do rolling upgrades. So again, it would be maybe good to give recommendations on how to use it. Like, yes, I like people that definitely discover ways, but I think it's kind of very, I don't know, it's a very abstract and a very abstract proposal. And then I know you're asking everyone to sort of come up with ways of using it, but I'm a little bit worried that not being, I wouldn't say like too prescriptive, but at least like giving some recommendations or ideas on how to use it will end up with us making a lot of different decisions and a lot of mistakes maybe. Like instantly everyone said, Oh, we shouldn't, you know, couple the version of the component with a software version. Great, if everyone already sort of agrees on that, maybe recommend that because I think everyone sort of intuitively thinks that's a bad idea, then maybe prevent sort of that from happening. I think that's not, and then also keeping track of things. I think that's just the worry I have the most. Code will start using this. And then if we don't keep track of things, things will probably end up in like, basically, I think the worst case, which is like an execution fork, right? Like if you don't keep track of the components and don't use them correctly, you will end up making a mistake in the code, like the implementation of the component and behave in a different way that wasn't for the current version. And then you will, you will, you know, cause an execution fork. That's just my two cents. Maybe we can do that outside of the proposal. For us as a team, here's the organizational process on how to use that and keep track of it.

**Alex Hentschel**:
I think you have a number of very good points here, And I'll try to respond to those. So, the current proposal already says, you know, there's here, you know, a software version can implement multiple component versions, you know, so that, like you're right, we should write here, you know, that that's the reason why we can't sort of one-to-one map them, you know. I appreciate that feedback. So I'll add that. In terms of next steps, that's why I'm saying, you know, let's not worry about the big picture, because at the moment, I don't think we understand the big picture well enough. And I think it is prohibitively time expensive for us to, like, learn the big picture without practical experience. So let's move the existing version beacon for the execution stack. Let's move that to this, right? That's the immediate next step. We already know what we're doing there, right? We don't want, I think it is, I think we're gonna not make progress, right? If we try to kind of solve the bigger picture, I think what makes sense here is to kind of try to use the tooling and see if that's useful for us. And in the sort of last thing, you know, the last comment you made is, you know, please make a proposal of how to use that. You know, like, um, that is, I, I think you're right that it would be helpful, you know, but on the other hand, I can't tell you how to version the execution stack, right? We had that conversation four months ago, you know, Leo, uh, Jordan wrote a blog post. Six months ago, you know, and, and the result is we're still patching on the, the old version beacon, uh, you know, because the new concept is too hazy and abstract because people don't, you know, I can't give you the full picture. But we also can't just say, OK, unless we have the full picture, we're not going to make progress switching over. I think that's a no-go. So the ask here is very clear. Please switch over the current version beacon to the dynamic protocol state. Let's make that happen. Let's use that as a learning. Let's not obsess about conventions, broader pictures. I think that will not work.

**Jordan Schalm**:
I think Alex is saying, we made this thing. We haven't really used it very much. We don't want to prescribe to you exactly how you should use it, because you maybe know better for your software stack that you own. And Bastian is saying, your proposal is kind of vague. I also don't really know what to do. So maybe the answer is borrowing better ideas from the execution team. Maybe just do the exact same thing that we did. Start there. It's very simple.

**Alex Hentschel**:
Yes, exactly. That's the ask. Execution team, let's take the existing version beacon, move that over, right? Or at least when you work on the existing version beacon, let's make sure that you're working in a mindset that can be moved over. Talk to me, just talk to me, right? But don't touch the existing version beacon without having talked to me.

**Bastian Mueller**:
Yeah, I think Jordan, you summarized it really well. Like Alex wants everyone to use it. And we also are interested in using it. But my point is also like, it's not really clear how to use it and and then like we already know that cases like for the security fix where we would like to use it and already there it's like showing that it's it's good if we make I'm not saying that we should introduce or prescribe any process but it's absolutely unclear you're saying like please use it okay like we will use But to use it, there's a lot of things that we can do wrong. And if we don't agree on how to use that blunt tool, I think we will cut ourselves. And I think giving some recommendations like, I don't know, how to use scissors.

**Jordan Schalm**:
I'm totally happy to give recommendations. I actually do have opinions about how the execution state should be versioned. I don't think we're ready to switch the version beacon over at the moment. But Alex's point is, when we are going to spend significant energy on improving or changing the version beacon at some point in the future, maybe in a week, maybe in three months, then come talk to us and we will dedicate time to helping make that happen.

**Alex Hentschel**:
Exactly. Thank you, Jordan. I appreciate that. Because at the moment, we've seen that the last six months, the proposal was to make and we keep patching on the existing old version beacon. And I'm not sufficiently confident that in that work we've considered the roadmap. And that's a problem. So I'm not saying switch it over. I'm only saying talk to me. That's the ask here. If you're spending time, talk to me or talk to Jordan. Jordan has good opinions. Probably better talk to Jordan. Yeah.

**Bastian Mueller**:
I think you're talking very much in particular. I don't know much about the version beacon. I'm working on one component and I have a particular use case. Which is I want to ship a security fix for my component. And I'd like to use your solution. And Alex, you would also want me to use that solution. And all I'm asking for is help me use this properly so that I don't cut myself. And I think all of you like Jordan have recommendations. Hey, don't use the same software version as the component version. I don't think it hurts to put that into the proposal and say like, hey, don't do that. That will cut yourself. I think that's, you know, like Jordan, maybe you have other recommendations. I think having some recommendations from...

**Unidentified Speaker**:
Sorry. I will add that now. Exactly.

**Bastian Mueller**:
Yeah. You know, like, or like some way of keeping track of this so that we don't make a mistake and cause an execution fork. I think that's sort of the worst thing we can possibly do. So preventing that might help. Just my two cents.

**Unidentified Speaker**:
Oh, it's my turn.

**Leo Zhang**:
Yeah, it's kind of, I'm not sure if it's implementation related, but it's kind of related to what Bastian is talking about. Yeah, Bastian is working on, I mean, one component and care about the latest version and all the bug is fixed. I also experienced issues like, for example, recently Samsung is down for, And I need to bring them back up. But they were down two HCU before. So if I just give them the HCU latest one, it wouldn't work, because we removed the box that they still had when they were down. So it would be nice that we have all the features. We support backward compatible. And then you just need the latest HCU. The version and they can just understand what should they behave before the first issue and then in between before the second issue and until the latest one. It would be so nice, so easier for the partners to catch up. And this only matters if the consistency is very critical. For example, If you have different result, produce different result at the specific height, then you would cause a fork, or you would produce a different result, and everything onward will be on a different fork. However, I feel like there will also be case where the bug maybe doesn't matter. You want to fix, like for kittens, if you fix a bug in the latest version, and I feel like you would have to keep if else, a feature toggle for the future versions so that it makes it easier for us to do HCU. Even though you want to fix the bug, but does the bug matter? So that in the older version, we still want to behave the buggy behavior so that it's still consistent. But I also can think of features where you don't want the buggy feature to appear even in the older version. So you would have to have this version-vacant behavior such that you behave the old way so that it's consistent before the activate height. But after the activated height, you just override the previous behavior as if this bug didn't appear. You know what I mean? So it's kind of two different behavior. One, you want to respect all the past behavior to be backward compatible because the consistency matters so much. Or maybe you don't care about it, right? You want to fix the bug forever, so you think the old one's behavior is wrong.

**Jordan Schalm**:
I think if you don't care about reproducing the old behavior, even if it's a bug, then we don't use this system at all, right? That's not a breaking change.

**Jordan Schalm**:
we use this system is for breaking change where we do actually need to exactly reproduce the old behavior and the change to the component version would result in different outputs.

**Bastian Mueller**:
To add to that maybe for some components that happens all the time and for other components it's much rarer. Like in cadence basically given that it influences the execution basically influence the execution result. Basically, you need to use this feature all the time. And I think there are probably other components that don't influence what network hashing function you use. Low-level networking detail is not a breaking change, so you don't have to use this feature, right? Exactly. And I think that's also reflected in our current code, right?

**Alex Hentschel**:
Because we have a version for exactly cadence and the execution stack, right? And for the all the other, we're fine with like the rare updates during sporks. And I think that is fine to go forward, right? Let's at least just use it for the existing, you know, where it's frequent, for the existing version beacon.

**Janez Podhostnik**:
Yeah. One benefit of the version beacon being somewhere that's in sync with our software version was that it would exactly tell you what version you need to execute with. So if you're re-executing from an old block, you can take an older version and it will execute until it can, and then it will stop and it will tell you like version beacon, you need to, the lowest possible version to execute this with is this one and go forward. So if we going to be a need for lookup tables. And I'm wondering where people will go for that lookup table. Yeah. Jan, I literally had the same thought yesterday.

**Bastian Mueller**:
We talked about somewhere where there's a single version number, and then I realized that it's just flipped. We can maybe take that offline afterwards, but I have an answer to that because I had the same thought yesterday. Get the same thought like, man, we need the somewhere for ranges, but it's just flipped around. So maybe we can discuss that like afterwards, given that we are again, like a little bit at time, I need to jump in a minute. Yeah. Thank you, Bastian. I appreciate that.

**Alex Hentschel**:
And I appreciate you sort of propagating the knowledge. I also wanted to say, if you want somewhere, you get somewhere, right? We can put somewhere in the dynamic protocol state. It's not integers. It can be a string to two numbers. Anything you want, a complex struct, right? So it's not that the new mechanism doesn't do it. It's just that you're now being asked, well, are you sure that that's the thing you actually really want? Yeah. Okay. Jan, do you have something?

**Jan Bernatik**:
I just, you know, my comment is on like discussion that was happening like 10 minutes ago, but I think it's still relevant somewhat. I think what we should try is to take what we tried to do with the Persian beacon. So basically, deploy cadence security fix or like a simple cadence change and use it for the specific purpose of doing a rolling upgrade and then use the version beacon for actually changing the behavior so that we don't have downtime. Let's see how that maps to the dynamic protocol state, right? How we would like change, still implement like the same use case, but switching from the version beacon to the dynamic protocol state. And that'd be a great use case and like evaluation of how does it work. And then all the other things that we talked about, you know, how to version like long-term changes and all that, those are like orthogonal problems that we can, you know, think about in the future. But I would like to see how that the mechanism basically can be switched to the dynamic protocol state.

**Unidentified Speaker**:
Thank you, Jan.

**Janez Podhostnik**:
That's my only ask here. Yeah, maybe And here, if we want to, I just have a technical question about the switch. I don't know how much time you still have.

**Unidentified Speaker**:
I can stay.

**Janez Podhostnik**:
So my question is, if we put a version beacon as is, if we put a somewhere that is the current version beacon into the protocol state. Is there any problem just using that in the existing component stop control that we have for its use? No.

**Alex Hentschel**:
I mean, I think that would be a great first step. It's not going to make your problems go away that sort of you have, like you don't specify an upper bound, right? Like if a new cadence version suddenly stops supporting an old thing, you know, but I think, yeah, so I think that is a perfectly fine solution, right? To just take what we have right now and put it into the dynamic protocol state, exactly that. I mean, that's essentially all that the dynamic protocol state does. It observes those existing events, or it observes those events and sort of track some on a block-by-block basis without really knowing what that means, you know, the information in those service events.

**Unidentified Speaker**:
Yeah. Go ahead, Leo.

**Alex Hentschel**:
Sorry, two quick questions.

**Leo Zhang**:
I think the version we can right now control by the signers. You send a smart contract and triggers an event and it goes to the protocol state, and then we saw that event changes. I think for this one, it's also the same, right? It will also be a smart contract listening to a certain...

**Unidentified Speaker**:
Exactly.

**Alex Hentschel**:
You know, the existing version beacon just stops at the service event. It just puts the service event on a block, right? And that's it, right? The protocol doesn't care about the service event. And that's the actually only change here, is that now the protocol state will extract that information and just sort of assign it to each block and track it for each block so you don't have to do it. And so if you don't have a long enough history to steam that old event, you still have the information. And that's a huge benefit in itself.

**Leo Zhang**:
And that it switches to view, and essentially that's all the changes. Right. Yeah. And to prevent node that hasn't been upgraded a version that is able to support the version. Yeah, I think it's similar to what Janez mentioned. It's a lookup table, right? We need to know what is the current execution stack version. If my current stack version only supports version 3, and then the dynamic portable state says I need 4 at block 100, at 100 I should like I should crash or I should stop, right? But where is the three goals?

**Alex Hentschel**:
So how do you do that currently? So you have to service event. The service event says, well, at height 100, we're changing to a new version.

**Leo Zhang**:
So how it works now is we just read the current logo version, and the version beacon says what is the logo version you need.

**Alex Hentschel**:
You could still do the same, right? The dynamic protocol state will say, you do three, you need four, right? And you just continue to read the logo version. That's fine. You know, it's maybe not sort of how I would recommend it, but if it's implemented like that, you know, the logic, what to do with the information you need for, you know, that's again in the implementation, right? Use what you currently have. You know, you want to make it more complex? Sure. Make it more complex, more general, you know, But at the moment, the dynamic protocol state doesn't really help you with that part.

**Unidentified Speaker**:
It only tracks the version assignment per block.

**Janez Podhostnik**:
Cool. I'm thinking if we need an ATU to switch to the protocol version from the So imagine, let's say that we want the same semver as we have for the version beacon for the execution component. Where do we go from there? That's my first question. Let's say I have decided that, or we have decided that that's what we want. What's next?

**Alex Hentschel**:
Okay, so what's next is that Jordan, you're in I here. Okay, let me hear that. I actually drew a little picture here for that. Hopefully that's good enough. So we're kind of mentally going through that exercise that you say, we want some version as the existing version beacon and the protocol, dynamic protocol stage should track that. The first thing we do is, this is one of the proposals that you will have those two new method names. Do you like that? Instead of a uint, it will be a sem version, like two integers or something, like a struct or whatever. We want to express that. Jordan, you and I will tell you, this is we're proposing that the dynamic protocol state then will have that interface. Do you like that? And if you do like that, you know, then we will implement this part from here, right? So we will, the dynamic protocol state, then from there on, we'll just observe Subversion Beacon event as it exists right now, right? And we'll just track that information and you will get that, you will have that API to read that out. On a per block basis. Then we will do a rolling upgrade for all the software, and we will specify one specific view from which on the protocol state will expose this information. So it will say previously, for any block prior to that, you'll get an interface that doesn't have those and from a block or I don't know, maybe it just gives you nil or something, you know. And after that view, you know, those numbers will have meaning or those methods will return meaningful values, right? And then it's, and your execution node software has to then understand, okay, you know, if this is let's say, you know, the execution state version is returning not a nil, then I have to check whether my implementation actually satisfies that. So again, it would be largely the same logic you already have for the version beacon. Just now that you don't have to keep track of those events anymore, you just go to the protocol state and ask for the number or ask for December. So the first step would be that Jordan, Yurii, and I implement that API. All right. And then, you know, then you can sort of roll out the new software version to the execution nodes to use that API. Yeah.

**Unidentified Speaker**:
Okay. All right.

**Alex Hentschel**:
Sounds like maybe a decent plan and maybe you talk to Bastian whether you actually want SEMVer, right? He said that there might be a reason to not use SEMVer and just use an integer. You know, you talk to you figure it out with him and let us know. Do you want Tenver? What do you want the name for those methods to be? And then we'll try to take it from there. Or Jordan, Yurii and I will take it from there.

**Janez Podhostnik**:
And then once that's out, we'll let you know, and then you can start using that new API. Okay. That sounds great. We'll probably sync on that again with the execution team and with Caden's team on the first steps.

**Alex Hentschel**:
Yes. Amazing. Exactly. Yeah. Okay. I appreciate that.

**Unidentified Speaker**:
Thank you.

**Alex Hentschel**:
Okay. Shall we call it now? Sorry, that took much longer. Yeah. Thank you for taking the time and thank you for kind of helping us to move this entire topic forward. I think once we get used to the new tooling, I think that will make our lives a lot easier, hopefully.

**Unidentified Speaker**:
Yeah. All right.

**Alex Hentschel**:
Thanks, everyone. I think we should wrap it now.

**Janez Podhostnik**:
Have a nice day. You too.

**Unidentified Speaker**:
Bye bye. Bye.
